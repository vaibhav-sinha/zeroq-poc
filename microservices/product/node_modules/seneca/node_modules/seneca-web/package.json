{
  "name": "seneca-web",
  "description": "A plugin that provides HTTP functionality for the Seneca framework.",
  "version": "0.4.3",
  "keywords": [
    "seneca",
    "web",
    "plugin"
  ],
  "author": {
    "name": "Richard Rodger",
    "url": "http://richardrodger.com"
  },
  "license": "MIT",
  "main": "web.js",
  "scripts": {
    "test": "./test.sh",
    "build": "./build.sh"
  },
  "files": [
    "LICENSE.txt",
    "README.md",
    "web.js",
    "http-router.js",
    "web"
  ],
  "dependencies": {
    "connect": "3.0.2",
    "eraro": "0.4.1",
    "json-stringify-safe": "5.0.1",
    "lodash": "2.4.2",
    "mstring": "0.1.2",
    "nid": "0.3.2",
    "norma": "0.3.0",
    "parambulator": "1.5.1",
    "rolling-stats": "0.1.1",
    "serve-static": "1.9.3"
  },
  "devDependencies": {
    "seneca": "plugin",
    "docco": "0.7.0",
    "jshint": "2.8.0",
    "mocha": "2.1.0",
    "success": "0.1.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/rjrodger/seneca-web.git"
  },
  "readme": "# seneca-web - a [Seneca](http://senecajs.org) plugin\n\n\n## Seneca web plugin\n\nThis plugin provides a web service API routing layer for Seneca action\npatterns. It translates HTTP requests with specific URL routes into\naction pattern calls. It's a built-in dependency of the Seneca module,\nso you don't need to include it manually. Use this plugin to define\nyour web service API.\n\nThis plugin supports [Express](http://expressjs.com/)-style middleware. \nTo use Seneca with [hapi](http://hapijs.com/), \nsee [chairo](https://www.npmjs.com/package/chairo) hapi plugin.\n\nFor a gentle introduction to Seneca itself, see the\n[senecajs.org](http://senecajs.org) site.\n\n\n### Support\n\nCurrent Version: 0.4.3\n\nTested on: [Seneca](//github.com/rjrodger/seneca) 0.6.3\n\n[![Build Status](https://travis-ci.org/rjrodger/seneca-web.png?branch=master)](https://travis-ci.org/rjrodger/seneca-web)\n\nBuilt and tested against versions: `0.10, 0.11, 0.12, iojs`\n\n[Annotated Source](http://rjrodger.github.io/seneca-web/doc/web.html)\n\nIf you're using this module, and need help, you can:\n\n   * Post a [github issue](//github.com/rjrodger/seneca-web/issues),\n   * Tweet to [@senecajs](http://twitter.com/senecajs),\n   * Ask on the [![Gitter chat](https://badges.gitter.im/rjrodger/seneca-web.png)](https://gitter.im/rjrodger/seneca-web).\n\n\n### Install\n\nThis plugin module is included in the main Seneca module:\n\n```sh\nnpm install seneca\n```\n\n\n## Quick example\n\nThis example defines some API end point URLs that correspond to Seneca actions:\n\n   * `GET /my-api/zig`: `role:api,cmd:zig`\n   * `GET /my-api/bar`: `role:api,cmd:bar`\n   * `GET /my-api/qaz`: `role:api,cmd:qaz`\n   * `POST /my-api/qaz`: `role:api,cmd:qaz`\n\n```JavaScript\nvar seneca = require('seneca')()\n\n\nseneca.add('role:api,cmd:zig',function(args,done){\n  done(null,{bar:args.zoo+'g'})\n})\n\nseneca.add('role:api,cmd:bar',function(args,done){\n  done(null,{bar:args.zoo+'b'})\n})\n\nseneca.add('role:api,cmd:qaz',function(args,done){\n  done(null,{qaz:args.zoo+'z'})\n})\n\n\nseneca.act('role:web',{use:{\n\n  // define some routes that start with /my-api\n  prefix: '/my-api',\n\n  // use action patterns where role has the value 'api' and cmd has some defined value\n  pin: {role:'api',cmd:'*'},\n\n  // for each value of cmd, match some HTTP method, and use the\n  // query parameters as values for the action\n  map:{\n    zig: true,                // GET is the default\n    bar: {GET:true},          // explicitly accepting GETs\n    qaz: {GET:true,POST:true} // accepting both GETs and POSTs\n  }\n}})\n\nvar express = require('express')\nvar app = express()\n\n// This is how you integrate Seneca with Express\napp.use( seneca.export('web') )\n\napp.listen(3000)\n\n// run: node test/example.js --seneca.log=type:act\n\n// try: curl -m 1 -s http://localhost:3000/my-api/bar?zoo=a\n// returns {\"bar\":\"ab\"}\n\n// try curl -m 1 -s -H 'Content-Type: application/json' -d '{\"zoo\":\"b\"}' http://localhost:3000/my-api/qaz\n// returns {\"qaz\":\"bz\"}\n```\n\n\n## Usage\n\nThe primary purpose of this plugin is to define URL routes that map to\naction patterns. This lets you turn your action patterns into a\nwell-defined web service API.\n\n* Use a separate set of action patterns for your web service\n  API. Don't expose your internal patterns! *\n\nThe `role:web` action accepts a `use` parameter that is a declarative\ndefinition of a set of routes. You specify a set of action patterns\nthat will be exposed, and the URL routes that map to each\npattern. Each call to the `role:web` action defines a middleware\nservice with a set of routes. Incoming requests are passed to each\nservice in turn until one matches. If none match, the request is\npassed onwards down the middleware chain.\n\nThe `use` parameter can also be an Express-style middleware function\nof the form `function( req, res, next )`. You are then free to handle\nthe action mapping yourself.\n\nTo use the services in your app, call `seneca.export('web')` to obtain\na wrapper middleware function that performs the route matching.\n\n\n#### Alternative Approach\n\nYou can use Seneca directly from with your route handlers by just\ncalling `seneca.act` directly. You don't need to use `seneca-web` at\nall. This approach may be more convenient if you already have a larger\nscale application architecture, or are integrating Seneca into an\nexisting system.\n\n\n#### Warning\n\nThis plugin does not provide an access control feature, or protect you\nfrom attacks such as request forgery. However, since it does support\nthe middleware pattern, you can use [other middleware\nmodules](http://expressjs.com/resources/middleware.html) to provide\nthese features.\n\n\n## Action Patterns\n\n### `role:web`\n\nDefine a web service as a mapping from URL routes to action patterns.\n\n_Parameters_\n \n   * `use`: mapping object, or middleware function\n\n#### Middleware Function\n\nWhen `use` is a function of the form `function(req,res,next) { ... }`\nit is considered to be a middleware function, and placed into the list\nof middleware provided by the _seneca-web_ plugin.\n\nUse this approach when you need to write special case custom code. The\n`req` parameter will contain a `seneca` property that gives you access\nto the Seneca instance bound to the current HTTP request. In a HTTP\nmiddleware context it's important to use the request specific Seneca\ninstance, as other plugins may have added context to that\ninstance. See, for example: [seneca-user](//github.com/rjrodger/seneca-user).\n\n```JavaScript\nseneca.add('zed:1',function(args,done){\n  done(null,{dez:2})\n})\n\nseneca.act('role:web', {use: function( req, res, next ){\n  if( '/zed' == req.url ) {\n\n    // NOTE: req.seneca reference\n    req.seneca.act('zed:1',function(err,out){\n      if(err) return next(err);\n\n      // assumes an express app\n      res.send(out)\n    })\n  }\n  else return next();\n}})\n```\n\n#### Route Action Mapping\n\nThe action mapping object is a convenience format for declarative\ndefinition of a HTTP API based on Seneca actions. You can see examples\nof this use-case in these projects:\n\n   * [seneca-examples project](http://github.com/rjrodger/seneca-examples)\n   * [Well App](http://github.com/nearform/well)\n   * [Nodezoo module search engine](http://github.com/rjrodger/nodezoo)\n\nYou specify a set of action patterns, and the URL routes that map to\nthese patterns. The set of patterns is specified using a _pin_, an\nexample pattern that includes wildcards for some properties.\n\nFor example, if you have defined the patterns:\n\n   * `seneca.add( 'role:color,cmd:red', ... )`\n   * `seneca.add( 'role:color,cmd:green', ... )`\n   * `seneca.add( 'role:color,cmd:blue', ... )`\n   * `seneca.add( 'role:sound,cmd:piano', ... )`\n\nThen the pin `role:color,cmd:*` will pick out the first three patterns:\n\n   * `role:color,cmd:red`\n   * `role:color,cmd:green`\n   * `role:color,cmd:blue`\n\nbut not `role:sound,cmd:piano` as that does not match the pin pattern.\n\nA simple mapping can then be defined as follows:\n\n```\nseneca.add('role:color,cmd:red', function( args, done ){\n  done( null, {color:'#F00'} )\n})\n\nseneca.add('role:color,cmd:green', function( args, done ){\n  done( null, {color:'#0F0'} )\n})\n\nseneca.add('role:color,cmd:blue', function( args, done ){\n  done( null, {color:'#00F'} )\n})\n\nseneca.act('role:web', {use:{\n  prefix: '/color',             // the URL prefix for the web service API\n  pin:    'role:color,cmd:*',   // the set of patterns to map\n  map: {\n    red:   true,                // GET /color/red triggers role:color,cmd:red\n    green: true,\n    blue:  true,\n  }\n}})\n```\n\nWhich creates an HTTP API that responds like so (review\n[test.sh](test.sh) and [test/example.js](test/example.js) to see full code):\n\n```bash\n$ curl -m 1 -s http://localhost:3000/color/red\n  {\"color\":\"#F00\"}\n\n$ curl -m 1 -s http://localhost:3000/color/green\n  {\"color\":\"#0F0\"}\n\n$ curl -m 1 -s http://localhost:3000/color/blue\n  {\"color\":\"#00F\"}\n```\n\nThe properties of the mapping define the routes and the action patterns to call:\n\n   * `prefix`: prefix string for the URL, in this case _/color_\n   * `pin`:    the pin that selects the actions\n   * `map`:    each property of this sub-object should correspond to a matched wildcard value, in this case: red, green, and blue\n\nThe map entries define the nature of the route. In the above example,\nthe default case is to respond to HTTP GET requests. The mapping forms\nURLs by appending the name of the wildcard value to the prefix to form\nthe full URL. So you end up with these endpoints:\n\n   * `GET /color/red`\n   * `GET /color/green`\n   * `GET /color/blue`\n\nTo respond to POST requests, do this:\n\n```\nseneca.act('role:web', {use:{\n  prefix: '/color',\n  pin:    'role:color,cmd:*',\n  map: {\n    red: { POST:true }\n  }\n}})\n```\n\nThe argument properties for your action are built from the URL\nparameters, query string, and body data, *merged* in that order of\nprecedence. You can modify this behaviour with the _useparams_ and\n_usequery_ settings, as described below.\n\nExample:\n\n```\n// just echo the args back out again!\nseneca.add('role:api,cmd:echo', function( args, done ){\n  done( null, args )\n})\n\nseneca.act('role:web', {use:{\n  prefix: '/api',\n  pin:    'role:api,cmd:*',\n  map: {\n    echo: {POST:true, suffix:'/:foo'}\n  }\n}})\n```\n\nWhich behaves as follows:\n\n```bash\n$ curl -m 1 -s -H 'Content-Type: application/json' -d '{\"zed\":\"c\"}' \\\nhttp://localhost:3000/api/echo/a?bar=b\n  {\"cmd\":\"echo\",\"role\":\"api\",\"zed\":\"c\",\"foo\":\"a\",\"bar\":\"b\"}\n```\n\n\n**Note: you do not have to list all the matching wildcards in a map. Only those\n  you list explicitly will be supported.**\n\nThe wildcard mapping object accepts the following optional properties\nthat let you refine the route specification:\n\n   * _METHOD_: any HTTP method (GET, POST, PUT, DELETE, etc); the value can be:\n      *  _true_: accept requests with this method.\n      * a middleware function: this allows you to completely customize the route.\n      * a method specification, see below.\n   * _alias_: custom URL path, concatenated to top level prefix; can contain Express-style route parameters: _/api/:bar_ sets _req.params.bar_.\n   * _suffix_: appended to route URL.\n   * _useparams_: merge any URL parameter values into the arguments for the Seneca action; default: `true` \n   * _usequery_: merge any URL query values into the arguments for the Seneca action; default: `true` \n   * _dataprop_: provide all request parameters inside a `data` property on the Seneca action, default: `false`\n   * _redirect_: perform a 302 redirection with the value as the new location URL.\n   * _handler_: function that translates inbound requests to Seneca actions, see below.\n   * _responder_: function that translates outbound Seneca results into HTTP response data, see below.\n   * _modify_: function that modifies the output object in some way (usually to delete sensitive fields), see below.\n\nThe response object that you provide to the seneca-web plugin via a\nSeneca action response, can contain a `http$` object to control the\nHTTP response. This object can have the optional properties:\n\n   * _status_: set the HTTP status code\n   * _headers_: sub-object defining custom header values\n   * _redirect_: redirect URL\n   \nFor each HTTP method, you can provide a method specification (as a\nsub-object) that overrides some of the route specification. Note that\nURL cannot be modified at the method level - that would be a different\nroute! In particular this means that the _alias_ can only be set at\nthe route specification level. If you need other behaviour, your best\noption is to write a custom middleware function, as noted above.\n\nThe method specification can contain the following properties, which\noverride the route specification:\n\n    * _useparams_\n    * _usequery_\n    * _dataprop_\n    * _handler_\n    * _responder_\n    * _modify_\n\nExample:\n\n```\nseneca.act('role:web', {use:{\n  prefix: '/color',\n  pin:    'role:color,cmd:*',\n  map: {\n    red: { POST:{dataprop:true} }\n  }\n}})\n```\n\n## Handler Function\n\nThis function has the form: `function( req, res, args, act, respond )`, where:\n     \n   * _req_: Express Request object\n   * _res_: Express Response object\n   * _args_: Seneca action arguments derived from the HTTP request parameters\n   * _act_: the Seneca action function, call with `act(args,respond)`\n   * _respond_: call to return a result: `respond(err,out)`\n\nProvide your own handler function when you need to customize the\nbehaviour of a route.\n\n\n#### Responder Function\n\nThis function has the form: `function( req, res, err, out )`, where:\n\n   * _req_: express Request object\n   * _res_: express Response object\n   * _err_: Seneca action error, if any\n   * _out_: Seneca action result, if any\n\nProvide your own responder function when you need to customize the\nexact data of the HTTP response.\n\n\n#### Modify Function\n\nThe output of a Seneca action is an object that is serialized to JSON\nand returned over HTTP. It is normally necessary to remove unwanted\nproperties that should not appear to network clients. The default\nmodifier removes all properties that contain a `$`, as these are used\nby Seneca for internal meta control. The `http$` is preserved, as this\nis used (and removed) by the default responder. Provide your own\nmodifer function to customize this behavior.\n\n\n#### General Middleware\n\nAt the top level, you can also provide general middleware functions\nthat get called before the mapping handlers are executed. These\nfunctions allow you to perform shared operations, such as extracting a\ncookie token, or attaching meta data to Request objects.\n\n```\nseneca.act('role:web', {use:{\n  prefix: '/color',\n  pin:    'role:color,cmd:*',\n\n  startware: function(req,res,next){\n    // attach something to every request\n    req.foo = \"bar\"\n    next()\n  }\n\n  premap: function(req,res,next){\n    // attach something only to mapped requests\n    req.zed = \"qux\"\n    next()\n  }\n\n  map: {\n    red: { POST:true }\n  }\n}})\n```\n\nThese general middleware functions are:\n\n   * _startware_: always executed, before any mappings, *even when there is no route match*\n   * _premap_: only executed when a mapping matches, and before the mapping; can also be used at the mapping level for route-specific behaviour\n   * _postmap_: executed only when a custom mapping middleware calls `next`.\n\nThe primary advantage of using the mapping specification over a custom\nmiddleware function is that seneca-web maintains a list of mapped\nroutes, and also performance statistics for those routes. Each time\nyou call `role:web` you define a service, and the service defines a\nnumber of routes.\n\n\n#### Example Code\n\nYou can see some (admittedly terse) examples of mapping specifications\nin the [test/test-server.js](test-server.js) and\n[test/test-client.js](test-client.js) testing code, or in the example\napplications noted above ([nodezoo.com](nodezoo.com) etc).\n\n\n### `role:web,cmd:routes`\n\nThis command returns an array of all of the routes that have been defined.\n\n```JavaScript\nseneca.act('role:web, cmd:routes', function(err, routes) {\n  console.log(routes);\n});\n```\n\nEach route is described as an object with properties:\n\n   * _url_: the route URL\n   * _method_: the HTTP method\n   * _srv_: the service that defined the route\n\n\n### `role:web,cmd:list`\n\nThis command returns an array of all of the service functions that have been defined.\n\n```JavaScript\nseneca.act('role:web, cmd:list', function(err, services) {\n  console.log(service);\n});\n```\n\n\n\n## Development & Test\n\nTo test, use:\n\n```sh\nnpm test\n```\n\nTo install separately (if you're using a fork or branch, say), use:\n\n```sh\nnpm install seneca-web\n```\n\nAnd in your code:\n\n```js\nvar seneca = require('seneca')({\n  default_plugins:{\n    web:false\n  }\n})\nseneca.use( require('seneca-web') )\n\n```\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rjrodger/seneca-web/issues"
  },
  "_id": "seneca-web@0.4.3",
  "_from": "seneca-web@0.4.3"
}
